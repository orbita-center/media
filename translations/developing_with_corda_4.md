[Перевод статьи Developing with Corda 4](https://medium.com/corda/developing-with-corda-4-36c96b4b3529)

![!](https://cdn-images-1.medium.com/max/2400/1*SfOX21aJBDRhTX7G6YJFcA.png)

Это обновленная версия статьи [Developing with Corda](https://lankydanblog.com/2018/06/05/developing-with-corda/), которую я написал в прошлом году. С тех пор многое изменилось, но с точки зрения разработчика, все должно быть очень похожим. В Corda 4 увеличили производительность, улучшили безопасность и постарались обеспечить лучший опыт разработчика. Кстати о последнем. Улучшение опыта разработчика требует добавления новой функциональности при удалении менее желательных частей. Но, чтобы сделать это и сохранить обратную совместимость при работе с Corda 3 и 4, требуется решить немного маленьких вопросов. Как было сказано - есть несколько отличий. Эти моменты будут освещены в данном материале, но основная задача – рассказать новым разработчикам основу для работы с Corda.

Если вы уже работали с Corda раньше, то беглого просмотра этого поста будет вполне достаточно. Если вы работали с Corda 3 и хотите перейти на 4ю версию, то быстрого взгляда на примеры кода должно хватить, чтобы увидеть, что что-то выглядит по-другому. Но, если вы новичок в Corda, то я рекомендую вам потратить немного времени, чтобы прочитать [What is Corda?](https://lankydanblog.com/2018/06/05/what-is-corda/) и [Corda key concepts](https://docs.corda.net/key-concepts.html).

С этого момента вы начинаете читать обновленную версию [Developing with Corda](https://lankydanblog.com/2018/06/05/developing-with-corda/).

В [What is Corda?](https://lankydanblog.com/2018/06/05/what-is-corda/) был дан обзор того, чего Corda пытается достичь, и какие архитектурные решения были приняты для этого. Эта информация очень полезна, поэтому мы можем понять некоторую перспективу платформы, но она не поможет нам в написании системы, которая может использовать Corda. Для этого нам нужно знать, как компоненты Corda работают и подходят друг другу, только тогда мы можем начать писать приложение, которое реально что-то делает и работает правильно с точки зрения Corda. Это похоже на изучения некого фреймворка. Но нам нужен голос в наших головах, чтобы напоминать нам время от времени, что мы на самом деле разрабатываем на основе платформы распределенного гроссбуха. Необходимо предпринять шаги, чтобы гарантировать, что приложения, которые мы создаем, правильно спроектированы.

В этом посте мы рассмотрим написание очень простого приложения на Corda.

Corda совместима с любым JVM языком. Я знаю, о чем вы думаете, но нет, Corda не написана на Java. На самом деле это написана на Kotlin. Это может потребовать некого дополнительного обучения, чтобы разобраться с Kotlin, но если вы обычно работаете с Java (как я), то это не займет у вас много времени. Поэтому я лично предлагаю писать вам код на Kotlin, чтобы сохранить весь стек на одном языке. Это поможет, когда вам потребуется разобраться в коде Corda, поскольку он будет похож на то, что вы только что писали. Очевидно, это только мое предложение, и вы можете вместо использовать Clojure. Но вам будет трудно получить какие-либо  примеры без предварительного преобразования их в эквиваленты Clojure.

Немного сложно погрузиться прямо в код, не разобравщись сначала с [ключевыми понятиями Corda](https://docs.corda.net/key-concepts.html). Лично я считаю, что документация по этому вопросу очень полезна и должна помочь вам справиться с основными вопросами.

В рамках статьи, мне кажется, что лучше всего пропустить конфигурацию, необходимую для фактической настройки узлов Corda, и сразу полностью сосредоточиться на написании Corda приложения.

# Обзор приложения

Прежде, чем мы сможем начать писать какой-либо код, нам нужно понять, что приложение пытается сделать. Вместо того, чтобы писать собственный пример, я буду опираться на [учебные материалы r3](https://github.com/corda/corda-training-solutions), поскольку этот пример достаточно прост для понимания. Этот пример "IOU" процесса ("я должен вам"), когда кто-то просит деньги, которые будут возвращены позже. В данном материале мы просто сконцетрируемся на выпуске долгового обязательства (IOU).

Ниже приведена схема последовательности, содержащая очень упрощенные шаги, связанные с выдачей IOU между двумя людьми:
![](https://cdn-images-1.medium.com/max/1600/1*UN-usDwMvdRkadkKuiZS-A.png)

Как видите, заемщик просит немного денег, если кредитор соглашается, то они оба запоминают, что заемщик должен кредитору немного денег. Это процесс несложный, но даже здесь он был еще немного упрощен. В этом процессе мы фактически не упоминали, когда и как деньги передаются между ними. Оставим этот перевод за рамками урока и просто сосредоточимся на сохранении намерения заимствования и кредитования денег между участниками.

Так как же этот процесс моделируется в Corda? Но, прежде чем мы продолжим, я хочу упомянуть о [ключевых концепциях Corda](https://docs.corda.net/key-concepts.html), поскольку они чрезвычайно важны для понимания того, что всё происходит должным образом.

Чтобы смоделировать этот процесс в Corda, нам нужно заменить некоторые шаги. Определение того, сколько денег занять, становится созданием транзакции, в которой содержится информация о занимаемых деньгах. Сторона, довольная тем, что предлагается, теперь представлена подписанием сделки своим ключом. Связь между заемщиком и кредитором заменяется отправкой сделки между ними. Дальше информация по сделке, кто кому и сколько должен, которая произошла, "высекается в камне" (фиксируется). Изменяя диаграмму с помощью этой новой информации, мы получем новую версию:

![](https://cdn-images-1.medium.com/max/1600/1*8LYhsfGcsZJYRR8wpcOw4Q.png)

Мы добавили несколько шагов, но процесс по-прежнему довольно прост. Диаграмма говорит сама за себя, и я не думаю, что могу добавить к ней что-то еще. Но что я скажу, так это то, что я еще немного упростил диаграмму, удалив `Нотариуса`, но только для того, чтобы сосредоточиться на процессе, который мы пытаемся смоделировать. Позже мы коснемся того, кто такое `Нотариус` очень-очень-очень кратко, где я предложу обратиться к [документации Corda](https://docs.corda.net/key-concepts-notaries.html) по этому вопросу (и сделаю это снова позже).

Эти диаграммы должны задать нам достаточно точное направление для того, чтобы реализовать Corda приложение для выпуска долгового обязательства между двумя сторонами.

# States (Состояния)

Переходим к программированию, и, давайте, начнем с состояний. Информацию о состояниях можно найти [здесь](https://docs.corda.net/key-concepts-states.html) в документации Corda. Состояния передаются по сети между узлами и в конечном итоге сохраняются в гроссбухе. В терминах транзакции состояние может быть входным или выходным, и в одной транзакции может существовать много таких состояний. Состояния неизменяемы, что необходимо для построения цепочки состояний, которые используются в транзакциях.

Как упоминалось ранее, я опираюсь на [учебные материалы r3](https://github.com/corda/corda-training-solutions). Ниже приведено `IOUState` состояние, которое будет передаваться в приложении:
```kotlin
@BelongsToContract(IOUContract::class)
data class IOUState(
  val amount: Amount<Currency>,
  val lender: Party,
  val borrower: Party,
  val paid: Amount<Currency> = Amount(0, amount.token),
  override val linearId: UniqueIdentifier = UniqueIdentifier()
) : LinearState {

  override val participants: List<Party> get() = listOf(lender, borrower)
}
```
В рамках концепции "долговой расписки" ("IOU") в значительной степени понять назначение всех полей можно без особого объяснения: `amount` - это сумма кредита, `lender` - сторона, ссужающая деньги (кредитор) и так далее. Единственное свойство, которое нуждается в объяснении, - это `linearId` типа `UniqueIdentifier`, этот свойсто в основном является `UUID`, фактически, это `internalId`, генерируемый из класса `UUID`.

Состояние `IOUState` наследуется от `LinearState`, которое является одним из общих типов состояния, которое Corda использует вместе с `FungibleState`. Оба они являются реализациями `ContractState`. `LinearState` состояния используются для представления состояний, которые, цитируя свои документы, *обновляются путем замены себя*. Таким образом при обновлении состояния оно должно быть включено как вход транзакции с выходом более новой версии. Старое состояние теперь будет помечено как `CONSUMED` из `UNCONSUMED` при сохранении в хранилище (`vault`) (абстракция Corda над базой данных).

`ContractState` требует свойство, которое возвращает участников состояния.

Участники являются очень важной частью состояния. Стороны, определенные в этом списке, получают состояние для сохранения в их собственном хранилище / базе данных. Если вы обнаружите, что ваше состояние не сохраняется стороной, которая должна знать об этом, то это, скорее всего, проблема. Я лично столкнулся с этой ошибкой и почувствовал боль.

В приведенном выше коде участники были включены не в конструктор, а в геттер для `participants`, который может использоваться для их получения. Здесь он возвращает кредитора (`lender`) и заемщика (`borrower`), так как они являются единственными сторонами, участвующими в сделке. Если вы хотите, то можете добавить участников в конструктор, как показано ниже:
```kotlin
@BelongsToContract(IOUContract::class)
data class IOUState(
  val amount: Amount<Currency>,
  val lender: Party,
  val borrower: Party,
  val paid: Amount<Currency> = Amount(0, amount.token),
  override val linearId: UniqueIdentifier = UniqueIdentifier(),
  override val participants: List<Party> = listOf(lender, borrower)
) : LinearState
```
Это позволяет определить участников, которые могут не быть включены в состояние. Какой вариант выбрать, зависит от вашего конретного случая, для данного туториала их достаточно.

Еще одна маленькая вещь, прежде чем перейти к следующему разделу. Аннотация `@BelongsToContract`, которая ранее не упоминалась, связывает состояние с контрактом (который мы рассмотрим очень скоро). Другой способ написать тот же код без аннотации - это переместить состояние во внутренний класс контракта, это будет выглядеть примерно так:
```kotlin
class IOUContract : Contract {

  data class IOUState(
    val amount: Amount<Currency>,
    val lender: Party,
    val borrower: Party,
    val paid: Amount<Currency> = Amount(0, amount.token),
    override val linearId: UniqueIdentifier = UniqueIdentifier(),
    override val participants: List<Party> = listOf(lender, borrower)
  ) : LinearState
}
```
Если вы не сделаете этого или не добавите аннотацию, вы получите следующее предупреждение:
```
[WARN] 16:41:55,620 [Test worker] contracts.TransactionState.<init> - State class net.corda.training.state.IOUState
is not annotated with @BelongsToContract, and does not have an enclosing class which implements Contract.
Annotate IOUState with @BelongsToContract(net.corda.training.contract.IOUContract.class) to remove this warning.
```
К счастью для вас, это сообщение и должно указывать вам правильное направление. Если вы когда-нибудь посмотрите на кодовую базу Corda, то вы увидите, что есть встроенные состояния, у которых существуют собственные контракты, написанные, как пример выше. Более подробную информацию об этом можно найти в [примечаниях к обновлению Corda 3 до 4](https://docs.corda.net/head/upgrade-notes.html#step-7-security-add-belongstocontract-annotations).

# Contracts (Контракты)

Следующие у нас контракты. Контракты используются для проверки состояний ввода и вывода для данной команды для всех сторон, участвующими в транзакции. Командой может быть, например, запрос текущего состояния или выплата причитающихся денег. Мы рассмотрим команды немного позже в этом разделе, но мы должны быть в состоянии понимать их сейчас.

Контракты довольно приятно писать из-за их выразительности. Мы можем написать условия в договоре, которые должны быть выполнены, чтобы транзакция была допустимой. Если некоторые условия не соблюдены, то будет выброшено исключение. Обычно это заканчивается прекращением выполнения текущей транзакции, поскольку вовлеченная сторона считает ее недействительной.

Условия используют DSL `requireThat`, которое определяет Corda для описания условий вместе с сообщениями об ошибках, которые подробно сообщают, что не так с транзакцией. Это позволяет легко и просто пройти через контракт и понять, что он делает, так как условия кода хорошо дополняются английскими сообщениями (или любым языком, на котором вы хотите их написать).

Ниже приведен пример контракта, который используется для проверки `IOUState` состояния, определенного выше:
```kotlin
class IOUContract : Contract {

  companion object {
    @JvmStatic
    val IOU_CONTRACT_ID = "net.corda.training.contract.IOUContract"
  }

  interface Commands : CommandData {
    class Issue : TypeOnlyCommandData(), Commands
    class Transfer : TypeOnlyCommandData(), Commands
    class Settle : TypeOnlyCommandData(), Commands
  }

  override fun verify(tx: LedgerTransaction) {
    val command = tx.commands.requireSingleCommand<IOUContract.Commands>()
    when (command.value) {
      is Commands.Issue -> requireThat {
        "No inputs should be consumed when issuing an IOU." using (tx.inputs.isEmpty())
        "Only one output state should be created when issuing an IOU." using (tx.outputs.size == 1)
        val iou = tx.outputStates.single() as IOUState
        "A newly issued IOU must have a positive amount." using (iou.amount.quantity > 0)
        "The lender and borrower cannot have the same identity." using (iou.borrower != iou.lender)
        "Both lender and borrower together only may sign IOU issue transaction." using
                (command.signers.toSet() == iou.participants.map { it.owningKey }.toSet())
      }
      is Commands.Transfer -> requireThat {
        // more conditions
      }
      is Commands.Settle -> {
        // more conditions
      }
    }
  }
}
```
Для данного поста я упростил контракт, поскольку мы сосредоточимся только на реализации одного типа команд. Давайте начнем сверху и будем двигаться вниз.

`IOUContract` реализует `Contract`, требующий функцию `verify` для проверки (отсюда и имя) транзакции.

## Имя класса контракта

Имя класса контракта указано здесь:
```kotlin
companion object {
  @JvmStatic
  val IOU_CONTRACT_ID = "net.corda.contracts.IOUContract"
}
```

Это используется в других частях Corda, когда требуется рефлексия. Другой способ, как определить имя, если вы не хотите указывать конкретную строку, как показан ниже:
```java
companion object {
  @JvmStatic
  val IOU_CONTRACT_ID = IOUContract::class.qualifiedName!!
}
```

## Commands (Команды)

Теперь мы можем поговорить о командах, которые я кратко упоминал ранее в этом разделе. Я поместил их ниже, поэтому вам не нужно прокручивать:
```kotlin
interface Commands : CommandData {
  class Issue : TypeOnlyCommandData(), Commands
  class Transfer : TypeOnlyCommandData(), Commands
  class Settle : TypeOnlyCommandData(), Commands
}
```
Эти команды используются для указания намерения провести транзакцию. Они были определены здесь из-за их связи с контрактом, поскольку они определяют, какие условия должны быть проверны. При этом вы можете поместить эти команды в другое место, если хотите, например, в их собственном файле или вне класса контракта, но в том же файле. Пока ваше решение наилучшим образом описывает ваше намерение, вы, скорее всего, идете в правильном направлении.

Поскольку эти команды просты и используются только для указания намерения, то в качестве расширения класса команды используем `TypeOnlyCommandData`. Доступны другие абстрактные классы, опывающиисе команды, которые мы можем использовать, например, `MoveCommand`.

Мы посмотрим, как использовать команды в следующем разделе.

## Осуществление проверки

Здесь происходит большая часть магии. Код был скопирован и вставлен ниже:
```kotlin
override fun verify(tx: LedgerTransaction) {
  val command = tx.commands.requireSingleCommand<IOUContract.Commands>()
  when (command.value) {
    is Commands.Issue -> requireThat {
      "No inputs should be consumed when issuing an IOU." using (tx.inputs.isEmpty())
      "Only one output state should be created when issuing an IOU." using (tx.outputs.size == 1)
      val iou = tx.outputStates.single() as IOUState
      "A newly issued IOU must have a positive amount." using (iou.amount.quantity > 0)
      "The lender and borrower cannot have the same identity." using (iou.borrower != iou.lender)
      "Both lender and borrower together only may sign IOU issue transaction." using
              (command.signers.toSet() == iou.participants.map { it.owningKey }.toSet())
    }
    is Commands.Transfer -> requireThat {
      // more conditions
    }
    is Commands.Settle -> {
      // more conditions
    }
  }
}
```
Функция `verify` проверяет, является ли предлагаемая транзакция допустимой. Если это так, транзакция будет продолжена дальше и, скорее всего, будет подписана и зафиксирована в гроссбухе. Но, если какое-либо из условий не выполняется, возникает исключение `IllegalArgumentException`, что приводит к прекращению предлагаемой транзакции.

Исключения, как правило, возникают, когда Corda сталкивается с невыполненными требованиями. Когда возникает исключение, предполагая, что ничто не пытается его поймать, выполнение завершается, и исключение продолжает "всплывать" до тех пор, пока оно не будет поймано или не окажется в выходных данных консоли. Это обеспечивает простой способ управления потоком транзакции, так как его можно остановить в любом месте его выполнения, даже на узле контрагента, и исключение будет передано инициатору.

В самом коде проверки извлекается команда, которую транзакция выполняет в своих состояниях, и в зависимости от типа для проверки действительности транзакции выполняются различные проверки. DSL `requireThat`, которое предоставляет Corda, позволяет записать условие, которое должно быть `true` для продолжения и сообщения об ошибке, которое выводится, если условие `false`.

Давайте рассмотрим одно из `requireThat` выражений немного подробнее:
```kotlin
val iou = tx.outputStates.single() as IOUState
"A newly issued IOU must have a positive amount." using (iou.amount.quantity > 0)
```

Здесь немного, чтобы что-то сейчас объяснять. DSL заботится о намеривании заявления. То, что я укажу, - это синтаксис:
> `<string message of what condition should be met> using <condition it must pass>`
 
Достаточно простой. Хотя я остановлюсь на этом моменте. То, что глупо ловило меня, когда я начал работать с Corda, была необходимость скобок в операторе `using`, если условие содержит пробелы. Игнорирование этих скобок может "подарить" вам некоторые ошибки. Наконец, DSL может содержать код, который не представляет собой проверку условий, позволяя инициализировать переменные, которые затем могут использоваться в фактических условиях.

Пока хватит про контракты. Они снова появятся в следующем разделе, когда мы посмотрим на контракт `IOUContract` в действии.

# Flows (Потоки)

В Corda потоки являются центральной точкой, где мы связываем все предыдущие разделы. Все состояния, контракты и команды собираются вместе, чтобы написать код, который будет предлагать новую транзакцию, отправить ее всем контрагентам для подписания и передачи ее в гроссбух, если все будут довольны. Внутри потоков вы можете делать намного более сложные вещи, но для этого урока мы будем придерживаться основ.

Основываясь на примерах из предыдущих разделов, теперь мы реализуем `IOUIssueFlow`. Ниже приведен код целиком, который мы затем разделим и рассмотрим:
```kotlin
@InitiatingFlow
@StartableByRPC
class IOUIssueFlow(val state: IOUContract.IOUState) : FlowLogic<SignedTransaction>() {
  @Suspendable
  override fun call(): SignedTransaction {
    val transaction: TransactionBuilder = transaction()
    val signedTransaction: SignedTransaction = verifyAndSign(transaction)
    val sessions: List<FlowSession> = (state.participants - ourIdentity).map { initiateFlow(it) }.toSet().toList()
    val transactionSignedByAllParties: SignedTransaction = collectSignature(signedTransaction, sessions)
    return recordTransaction(transactionSignedByAllParties, sessions)
  }

  private fun transaction(): TransactionBuilder {
    val notary: Party = serviceHub.networkMapCache.notaryIdentities.first()
    val issueCommand: Command<IOUContract.Commands.Issue> =
      Command(IOUContract.Commands.Issue(), state.participants.map { it.owningKey })
    val builder = TransactionBuilder(notary = notary)
    builder.addOutputState(state, IOUContract.IOU_CONTRACT_ID)
    builder.addCommand(issueCommand)
    return builder
  }

  private fun verifyAndSign(transaction: TransactionBuilder): SignedTransaction {
    transaction.verify(serviceHub)
    return serviceHub.signInitialTransaction(transaction)
  }

  @Suspendable
  private fun collectSignature(
    transaction: SignedTransaction,
    sessions: List<FlowSession>
  ): SignedTransaction = subFlow(CollectSignaturesFlow(transaction, sessions))

  @Suspendable
  private fun recordTransaction(transaction: SignedTransaction, sessions: List<FlowSession>): SignedTransaction =
    subFlow(FinalityFlow(transaction, sessions))
}

@InitiatedBy(IOUIssueFlow::class)
class IOUIssueFlowResponder(val flowSession: FlowSession) : FlowLogic<SignedTransaction>() {

  @Suspendable
  override fun call(): SignedTransaction {
    val signTransactionFlow = object : SignTransactionFlow(flowSession) {
      override fun checkTransaction(stx: SignedTransaction) = requireThat {
        val output = stx.tx.outputs.single().data
        "This must be an IOU transaction" using (output is IOUContract.IOUState)
      }
    }
    val signedTransaction = subFlow(signTransactionFlow)
    return subFlow(ReceiveFinalityFlow(otherSideSession = flowSession, expectedTxId = signedTransaction.id))
  }
}
```
Поток этого кода (да, это каламбур 😅) довольно прост и, возможно, будет одним из типичных потоков, которые вы напишете в своем собственном приложении. Я могу сказать, что для большинства потоков, которые я написал за последний год или около того, как для работы, так и для других моих постов в блоге, использовалась такая структура. Если честно, всякий раз, когда я начинаю новый проект, я копирую и вставляю один поток, который выглядит следующим образом, а затем начинаю с него. Эта стратегия меня еще не подводила 🙂.

Конечно, вам не нужно писать свои потоки точно так же. Я разделил `call` функцию на множество мелких функций, и это действительно делает код намного длиннее. Но я не думаю, что что-то можно прочитать проще, чем это 😎.

Ладно, хватит обо мне, вернемся к коду.

Что он делает:

* Создает состояние
* Добавляет состояние в новую транзакцию
* Проверяет транзакцию с помощью контракта
* Подписывает транзакцию
* Запрашивает подписи контрагентов
* Сохраняет транзакцию для всех участников

Теперь, когда мы знаем шаги, которые выполняются в этом потоке, мы можем объяснить, как это происходит в коде.

## Иницилизация потока

Вот код снова только с выделенной из него иницилизацией потока:
```kotlin
@InitiatingFlow
@StartableByRPC
class IOUIssueFlow(val state: IOUContract.IOUState) : FlowLogic<SignedTransaction>() {
  @Suspendable
  override fun call(): SignedTransaction {
    val transaction: TransactionBuilder = transaction()
    val signedTransaction: SignedTransaction = verifyAndSign(transaction)
    val sessions: List<FlowSession> = (state.participants - ourIdentity).map { initiateFlow(it) }.toSet().toList()
    val transactionSignedByAllParties: SignedTransaction = collectSignature(signedTransaction, sessions)
    return recordTransaction(transactionSignedByAllParties, sessions)
  }

  private fun transaction(): TransactionBuilder {
    val notary: Party = serviceHub.networkMapCache.notaryIdentities.first()
    val issueCommand: Command<IOUContract.Commands.Issue> =
      Command(IOUContract.Commands.Issue(), state.participants.map { it.owningKey })
    val builder = TransactionBuilder(notary = notary)
    builder.addOutputState(state, IOUContract.IOU_CONTRACT_ID)
    builder.addCommand(issueCommand)
    return builder
  }

  private fun verifyAndSign(transaction: TransactionBuilder): SignedTransaction {
    transaction.verify(serviceHub)
    return serviceHub.signInitialTransaction(transaction)
  }

  @Suspendable
  private fun collectSignature(
    transaction: SignedTransaction,
    sessions: List<FlowSession>
  ): SignedTransaction = subFlow(CollectSignaturesFlow(transaction, sessions))

  @Suspendable
  private fun recordTransaction(transaction: SignedTransaction, sessions: List<FlowSession>): SignedTransaction =
    subFlow(FinalityFlow(transaction, sessions))
}
```
Во-первых, класс потока аннотируется `@InitiatingFlow` и расширяет `FlowLogic`. Эта комбинация необходима для любого потока, который запрашивает связь с контрагентом. `FlowLogic` содержит одну абстрактную функцию `call`, которую надо реализовать в потоке. Здесь происходит вся магия. Когда поток запускается, что мы рассмотрим позже, выполняется вызов, и запускается любая логика, помещенная в функцию. `FlowLogic` является генериком (`FlowLogic <T>`), где `T` определяет тип возвращаемого значения из `call`. В приведенном выше примере возвращается `SignedTransaction`, но вполне возможно использовать `FlowLogic<Unit>`, если у вас нет желания возвращать что-либо обратно вызывающей стороне потока.

Далее идет аннотация `@StartableByRPC`. Это позволяет вызывать поток из соединения RPC, которое является интерфейсом между внешней стороной узла Corda и его внутренними компонентами. Мы еще немного коснемся этого, когда рассмотрим запуск потока.

Появляется еще одна аннотация. `@Suspendable` на самом деле из `quasar-core`, а не из одной из собственных библиотек Corda. Если вы забудете добавить её, то увидите ошибку ниже и ваш поток зависнет:
```
java.lang.IllegalArgumentException: Transaction context is missing. This might happen if a suspendable method is not annotated with @Suspendable annotation.
```

`@Suspendable` необходим для всех функций, которые взаимодействуют с контрагентом. Как следует из названия `suspendable`, аннотация позволяет приостановить функцию, пока контрагент имеет дело со своей стороной транзакции. Здесь происходит немного магии, и это кратко затронуто в [документации Corda по потокам](https://docs.corda.net/flow-state-machines.html#suspendable-functions).

В моей первоначальной версии этого поста я говорил об ошибке, запутанной и несвязанной. Но, похоже, что эта ситуация разрешилась, и теперь было выдается сообщение об ошибке, объясняющее, что именно не так. Тем не менее, если вы когда-нибудь получите какие-то странные ошибки, все равно стоит дважды проверить, что у вас указана `@Suspendable` в нужном месте.

Связываем это с примером. `call`, `collectSignatures` и `recordTransaction` помечены `@Suspendable`. И `collectSignatures`, и `recordTransaction` вызывают `subFlow`, которые взаимодействуют с контрагентами. `call` с другой стороны нуждается в аннотации, потому что он передает управление нашим собственным функциям, которые приостанавливаются.

Это наша первая встреча с `subFlows` (подпотоками). Я помещу небольшой раздел ниже, чтобы быстро рассказать о них и дать теме объяснение, которого оно заслуживает.

Вернемся к поставленной задаче.

Отсутствие аннотации `@Suspendable` - одна из самых распространенных ошибок, с которыми, как я обратил внимание, сталкиваются другие разработчики. Итак, позвольте мне повторить этот момент еще раз.

> Вам необходимо добавить аннотацию `@Suspendable` любой функции, которая взаимодействует с контрагентом

Вы не понимаете, как трудно не упростить все это вплоть до 🤦‍.

> Вам нужно добавить аннотацию `@Suspendable` к любой функции, которая приостанавливается.

Давай считать, что вы мне поняли.

Теперь мы закончили с аннотациями, теперь мы можем более внимательно посмотреть на содержание функции `call`.

## Создание транзакции

Сначала рассмотрим построение предложенной транзакции, соответствующий код был приведен ниже:
```kotlin
private fun transaction(): TransactionBuilder {
  val notary: Party = serviceHub.networkMapCache.notaryIdentities.first()
  val issueCommand: Command<IOUContract.Commands.Issue> =
    Command(IOUContract.Commands.Issue(), state.participants.map { it.owningKey })
  val builder = TransactionBuilder(notary = notary)
  builder.addOutputState(state, IOUContract.IOU_CONTRACT_ID)
  builder.addCommand(issueCommand)
  return builder
}
```
Для целей этого поста мы будем предполагать, что есть только один Нотариус, который позволяет нам быть ленивыми и просто брать первый из списка. Если вы не знаете, что такое Нотариус, как и ранее, я предлагаю вам ознакомиться с [основными понятиями Corda](https://docs.corda.net/key-concepts-notaries.html), чтобы получить хорошее объяснение по этой теме. На данный момент я предоставлю вам минимум для продолжения. Нотариус - это узел, единственной целью которого является проверка того, что в отправленной ему транзакции не было двойных расходов. Дополнительная проверка также может быть запущена, если она настроена для этого.

`serviceHub` доступен с тех пор, как мы отнаследовали `FlowLogic`; функция `networkMapCache` предоставляет идентификационные данные сторон в сети, а `notaryIdentities` сужает их до Нотариусов. Как я упоминал ранее, мы будем ленивы и просто возьмем первого из этого списка. Способ получения Нотариуса, который вы хотите использовать в транзакции, может меняться в зависимости от ваших требований.

Далее мы создаем команду, которая представляет цель транзакции. В этом случае мы используем `IOUContract.Commands.Issue`, которая была определена ранее. При создании команды нам также необходимо предоставить открытые ключи сторон, необходимых для подписания транзакции. 'it' - это 'Party' (сторона/участник), а `owningKey` представляет собой открытый ключ. Только подписавшиеся в этой транзакции содержатся в свойстве состояния `participants`, но вместо этого можно было бы передать независимый список.

Все компоненты, необходимые для транзакции, теперь получены или созданы. Теперь нам нужно начать собирать все вместе. `TransactionBuilder` делает именно это. Нотариус добавляется с помощью одного из конструкторов `TransactionBuilder`, но при желании его можно установить позже. `addOutputState` принимает `state` (состояние), переданное в поток, вместе с именем контракта, которое его проверит. Помните, я упомянул два способа получить это имя: через открытое свойство в объекте (как это обычно делает Corda) или вручную добавляя имя класса, - в любом случае, конечная цель остается той же. Последний компонент, который мы добавляем к этой транзакции, - это команда, которую мы создали.

## Проверка и подписание транзакции

Следующий блок кода посвящен проверке и подписанию транзакции, опять же соответствующий код представлен ниже:
```kotlin
private fun verifyAndSign(transaction: TransactionBuilder): SignedTransaction {
  transaction.verify(serviceHub)
  return serviceHub.signInitialTransaction(transaction)
}
```

Как только мы обрадуемся, что всё, что мы хотели включить в транзакцию, включено, мы должны это проверить. Просто вызовите функцию `verify`, которую предоставляет `TransactionBuilder`. Эта функция обеспечивает проверку внутри контракта, запущенного для транзакции. Как упоминалось ранее в разделе контракта, если какое-либо из условий контракта не выполняется, то создается исключение. Поскольку в этом коде нет попыток перехватить исключение, поток завершится ошибкой, поскольку исключение распространяется по стеку.

После того, как транзакция прошла проверку, для нас (инициатора) транзакция действительна и должна быть подписана. Для этого вызывается `serviceHub.signInitialTransaction`. Это создает новую транзакцию `SignedTransaction`, которая в настоящее время подписана только инициатором. Подписание этой транзакции станет важным позже, когда Нотариус проверит, что транзакция была подписана всеми вовлеченными сторонами.

## Сбор подписей у контрагентов

Теперь транзакция проверена и подписана инициатором. Следующим шагом является запрос подписей контрагентов, участвующих в транзакции. Как только это будет сделано, транзакция может быть сохранена в каждом хранилище, поскольку все согласны с тем, что транзакция является правильной и соответствует их потребностям.

Ниже приведен код, отвечающий за сбор подписей у контрагентов:
```kotlin
@Suspendable
private fun collectSignature(
  transaction: SignedTransaction,
  sessions: List<FlowSession>
): SignedTransaction = subFlow(CollectSignaturesFlow(transaction, sessions))
```
Контрагенты по данной сделке определяются сторонами в списке `participants` (участников). Если вспомнить, как было построено поле участников в состоянии, то в нём содержались только две стороны, поэтому только две стороны должны будут подписать сделку. Хотя это утверждение верно, транзакция уже была подписана инициатором, поэтому теперь только один контрагент (`lender` *кредитор*) должен подписать её.

Чтобы отправить транзакцию контрагентам, надо сначала создать с ними сеанс. Код ниже делает именно это, и возвращаемые из него сессии являются входными данными для функции выше:
```kotlin
val sessions: List<FlowSession> = (state.participants - ourIdentity).map { initiateFlow(it) }.toSet().toList()
```
Функция `initiateFlow` создает сессию для другого узла, который принимает `Party` и возвращает `FlowSession`, который будет использоваться для связи. Как уже упоминалось, инициатору не нужно снова подписывать транзакцию, поэтому в коде для него не создаётся сессия связи. Благодаря тому, что мы знаем, кто участвует в этой транзакции, вместо этого можно было создать единственныую сессию `FlowSession`:
```kotlin
val session = initiateFlow(state.lender)
```
Вместо того чтобы полагаться на список `participants` (участников), мы просто создадим сессию для `lender` (кредитора), поскольку наши знания о состоянии указывают на то, что они (инициатор и кредитор) являются единственными контрагентами.

`FlowSession` необходимо использовать внутри `CollectSignaturesFlow` вместе с `SignedTransaction`, которая на данный момент подписана только инициатором. `CollectSignaturesFlow` отправляет `SignedTransaction` контрагенту (контрагентам, если нескольким необходимо подписать), и ожидает их ответа. Мы посмотрим, как ответ будет отправлен обратно в следующем разделе. После возврата `SignedTransaction` завершена, так как подписана всеми и может быть сохранена.

## Сохранение подписанной транзакции

Следующий код сохраняет транзакцию:
```kotlin
subFlow(FinalityFlow(transaction, sessions))
```
Хотя здесь всего одна строка, этот кусок кода мощен, как удар. `FinalityFlow`, скорее всего, всегда будет вызываться в конце ваших потоков, по крайней мере, для простых потоков в любом случае.

Вызов `FinalityFlow`:
* Отправит транзакцию Нотариусу (при необходимости)
* Запишит транзакцию в хранилище инициатора
* Сообщит участникам транзакции о необходимости записать ее в их хранилища

Немного поговорим о первом пункте. Транзакция отправляется Нотариусу, только если она имеет какие-либо входные состояния, которые используются. Это связано с тем, что Нотариусы проверяют ранее потраченные средства, чтобы избежать двойных расходов. Поэтому, если нет входных состояний, то Нотариусу нечего делать. Не посылать его Нотариусу - это в основном оптимизация, которая убирает потраченную впустую работу.

Последние два шага зависят от Нотариуса, который находит транзакцию действительной. Если это не так, как обычно, генерируется исключение, ведущее к выходу из потока.

## The Responder Flow (Поток ответчика)

Всё в потоке, на который мы смотрели до сих пор, находится на стороне инициатора процесса. Во время примера было несколько раз, когда транзакция была отправлена контрагенту, и происходили некоторые «вещи». В этом кратком разделе мы рассмотрим код, который будет запускать контрагент:
```kotlin
@InitiatedBy(IOUIssueFlow::class)
class IOUIssueFlowResponder(val flowSession: FlowSession) : FlowLogic<SignedTransaction>() {

  @Suspendable
  override fun call(): SignedTransaction {
    val signTransactionFlow = object : SignTransactionFlow(flowSession) {
      override fun checkTransaction(stx: SignedTransaction) = requireThat {
        val output = stx.tx.outputs.single().data
        "This must be an IOU transaction" using (output is IOUContract.IOUState)
      }
    }
    val signedTransaction = subFlow(signTransactionFlow)
    return subFlow(ReceiveFinalityFlow(otherSideSession = flowSession, expectedTxId = signedTransaction.id))
  }
}
```
Как и всё прежде, этот код был приведен ранее в посте.

Наиболее важной строкой в этом классе является аннотация `@InitiatedBy`, которая указывает, от какого потока он принимает запросы и куда отвечает на них. В этом примере это `IOUIssueFlow`, через который мы уже прошли.

Поскольку `IOUIssueFlowResponder` также является потоком, он наследует `FlowLogic` и должен будет реализовать свою собственную версию функции `call`. `FlowSession` в конструкторе - это сессия, которая использовалась инициатором для связи с этим потоком. `@Suspendable` также используется для `call`, как это было и в исходном потоке.

`SignTransactionFlow` - это другая половина `CollectSignaturesFlow`, которая была вызвана в инициаторе. Это абстрактный класс, который требует реализации `checkTransaction`. Он содержит любую дополнительную проверку, которую контрагент выполнить с транзакцией при желании. Функция `call` в `SignTransaction` все равно будет проверять транзакцию по контракту, так что это шанс для всего остального (обеспечение соответствия транзакции стандартам контрагента). `checkTransaction` также может содержать совсем мало кода и даже может быть пустым, если проверки контракта достаточно. Вместо того, чтобы показывать вам, как это будет выглядеть, я позволю вам использовать свое яркое воображение, чтобы представить пустую функцию...

Далее вызывается `subFlow` для реализации `SignTransactionFlow` и его выполнения. Проверка в контракте выполняется, после чего следует содержимое `checkTransaction`, и если все проверки проходят успешно, то транзакция подписывается и отправляется туда, откуда она пришла.

Последний шаг - это вызов метода `ReceiveFinalityFlow`. Это отличается от того, как это раньше работало в Corda 3, где вам не нужно было вручную получать транзакцию. В любом случае этот подпоток должен быть вызван для записи транзакции в хранилище контрагента. Идентификатор ожидаемой транзакции для записи извлекается из транзакции, которая была подписана заранее. После этого момента оба контрагента сохранят транзакцию в своем хранилище, готовую к использованию в будущих потоках.

Код в этом классе может быть настолько простым или сложным, насколько это необходимо. Для примера, используемого в этом уроке, код достаточно простой. Это может измениться в зависимости от ваших требований и того, что необходимо сообщить инициатору и его ответчикам.

## Работа с subFlows (подпотоками)

Вы должны были заметить функцию `subFlow`, разбросанную по примерам кода. Наконец, я думаю, что мы дошли до того момента, когда я смогу рассказать о ней немного подробнее.

`subFlows` - это потоки, подобные тому, который мы рассматривали ранее, которые вызываются из других потоков. Например, `CollectSignaturesFlow` и `FinalityFlow` не могут быть инициированы сами по себе, так как они не аннотированы `@InitiatingFlow`, поэтому их можно использовать только из `subFlow`. Большинство потоков, предоставляемых Corda из "коробки", попадают в эту же категорию.

Все, что делает `subFlow` - это запускает поток, передаваемый в него, вызывая функцию потока `call` и возвращая то, что поток обычно возвращает. Поток не требует ничего особенного для передачи в `subFlow`, если нам когда-либо понадобится, `IOUIssueFlow` может быть передан в него из другого потока.

Corda предоставляет потоки для многих типичных операций, которые необходимо повторять в наших собственных потоках. Они вызываются через `subFlow` и включают: `CollectSignaturesFlow`, `SignTransactionFlow`, `SendTransactionFlow`, `ReceiveTransactionFlow` и многие другие.

# Запуск потока

В этом последнем разделе мы рассмотрим, как вызвать поток извне узла Corda.

Есть несколько способов сделать это, каждый работает немного по-своему. Но давайте выберем короткий и простой и рассмотрим только стандартную функцию `startFlow`:
```kotlin
proxy.startFlow(::IOUIssueFlow, state)
```
Вот так. Как я уже сказал, коротко и просто. `proxy` имеет тип `CordaRPCOps`, который содержит множество функций, используемых для взаимодействия с узлом Corda через RPC. `startFlow` - одна из таких функций. Он принимает имя класса потока вместе с любыми аргументами, которые являются частью конструктора потока. Таким образом, в этом примере `call` функция `IOUIssueFlow` будет вызвана с передачей состояния `IOUState` для использования в потоке.

Возвращается `FlowHandle<T>`, где `T` - это тот же генерик тип вызванного потока, в данном случае `SignedTransaction`. Затем можно вызвать `returnValue` для извлечения `CordaFuture`, что позволяет получить результат, как только он станет доступен. `CordaFuture` является подтипом стандартного `Future` с несколькими доступными дополнительными методами, одним из которых является `toCompletableFuture`, который может быть или не быть полезным для вас (в любом случае был полезен для меня).

# Заключение

Вот мы и подошли к заключению.

Надеюсь, этот пост помог вам понять, как разрабатывать с Corda. Есть еще много всего, чему можно научиться, поскольку я рассмотрел только основы. Мы реализовали IOU процесс ("я должен вам") при проверке компонентов, необходимых для этого. Состояния - это факты, которыми обмениваются стороны в сети, контракты используются для проверки транзакций, а потоки содержат логику для предложения новых транзакций. С этой информацией вы должны быть готовы, чтобы начать писать свои собственные потоки. Вы можете сделать гораздо больше с потоками, которые не были рассмотрены в данной статье, но полученные основы должны хорошо помочь вам при написании любых потоков, которые вы захотите реализовать.

Если вы сочли данный материал полезным и хотите быть в курсе выхода моих постов, то можете подписаться на меня в Twitter по адресу [@LankyDanDev](https://twitter.com/lankydandev).

Также можно присоединиться к [каналу Corda в Slack](https://slack.corda.net/), если у вас есть какие-либо вопросы или вы хотите узнать больше о Corda после прочтения этого поста.